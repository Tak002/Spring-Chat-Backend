name: build-and-deploy

on:
  push:
    branches: [ "main" ,"production"]

jobs:
  docker-build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Inject WebSocket endpoint to index.html
        run: |
          WS_ENDPOINT="${{ secrets.WS_ENDPOINT }}"
          FILE=./chat-ws/src/main/resources/static/index.html
          if [ -n "$WS_ENDPOINT" ]; then
            echo "Injecting WS_ENDPOINT=$WS_ENDPOINT into $FILE"
            sed -i "s|__WS_ENDPOINT__|$WS_ENDPOINT|g" "$FILE"
          else
            echo "[WARN] WS_ENDPOINT not set; keeping default (localhost)."
          fi
      - name: Login to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push image
        uses: docker/build-push-action@v6
        with:
          context: ./chat-ws
          file: ./chat-ws/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_IMAGE }}:latest
            ${{ secrets.DOCKER_IMAGE }}:${{ github.sha }}
          cache-from: type=gha           # ← 캐시 사용
          cache-to: type=gha,mode=max    # ← 캐시 저장(최대)

  deploy:
    needs: docker-build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # 서버로 배포용 compose 업로드 (prod 전용 오버라이드)
      - name: Upload compose (prod)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          port: ${{ secrets.SERVER_SSH_PORT }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "infra/docker-compose.prod.yml"
          target: "/opt/chat/"
          strip_components: 1   # ★ infra/를 벗겨서 /opt/chat/docker-compose.prod.yml 로 배치
          overwrite: true

      - name: Deploy over SSH (compose pull + up)
        uses: appleboy/ssh-action@v1.0.3
        env:
          DOCKER_IMAGE: ${{ secrets.DOCKER_IMAGE }}
          IMAGE_TAG: ${{ github.sha }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          port: ${{ secrets.SERVER_SSH_PORT }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DOCKER_IMAGE,IMAGE_TAG,REGISTRY_USERNAME,REGISTRY_TOKEN
          script: |
            set -euo pipefail
            mkdir -p /opt/chat
            cd /chat
            
            # 1) 환경변수 설정
            export DOCKER_IMAGE="${DOCKER_IMAGE}"
            export IMAGE_TAG="${IMAGE_TAG}"
            
            # 2) 레지스트리 로그인 (기본 docker.io, GHCR이면 ghcr.io 명시)
            : "${REGISTRY_SERVER:=docker.io}"
            echo "${REGISTRY_TOKEN}" | docker login "${REGISTRY_SERVER}" -u "${REGISTRY_USERNAME}" --password-stdin
      
            # 3) 도커 컴포즈로 서비스 배포 (postgres, redis는 재생성하지 않음)
            docker compose -f docker-compose.prod.yml up -d --no-recreate postgres redis
            docker compose -f docker-compose.prod.yml pull app-chat-ws
            docker compose -f docker-compose.prod.yml up -d --no-deps app-chat-ws
            docker image prune -f
            
