name: build-and-deploy

on:
  push:
    branches: [ "main" , "production"]

jobs:
  docker-build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Inject WebSocket endpoint
        run: |
          WS_ENDPOINT="${{ secrets.WS_ENDPOINT }}"
          FILE=./chat-ws/src/main/resources/static/index.html
          if [ -n "$WS_ENDPOINT" ]; then
            echo "Injecting WS_ENDPOINT=$WS_ENDPOINT into $FILE"
            sed -i "s|__WS_ENDPOINT__|$WS_ENDPOINT|g" "$FILE"
          else
            echo "[WARN] WS_ENDPOINT not set; keeping default (localhost)."
          fi
      - name: Login to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push image
        uses: docker/build-push-action@v6
        with:
          context: ./chat-ws
          file: ./chat-ws/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_IMAGE }}:latest
            ${{ secrets.DOCKER_IMAGE }}:${{ github.sha }}

  deploy:
    needs: docker-build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Prepare SSH key
        shell: bash
        run: |
          set -euo pipefail
          KEY_FILE="${RUNNER_TEMP}/ec2.key"
          printf '%s' "${{ secrets.SERVER_SSH_KEY }}" > "$KEY_FILE"
          sed -i 's/\r$//' "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          echo "KEY_FILE=$KEY_FILE" >> "$GITHUB_ENV"

      - name: Deploy over native SSH (docker compose)
        shell: bash
        env:
          HOST:         ${{ secrets.SERVER_HOST }}
          USER:         ${{ secrets.SERVER_USER }}
          PORT:         ${{ secrets.SERVER_SSH_PORT }}
          IMAGE:        ${{ secrets.DOCKER_IMAGE }}
          REG_USER:     ${{ secrets.REGISTRY_USERNAME }}
          REG_TOKEN:    ${{ secrets.REGISTRY_TOKEN }}
          APP_PORT:     ${{ secrets.APP_PORT }}
        run: |
          set -euo pipefail
          : "${PORT:=22}"
          : "${APP_PORT:=8080}"

          IMAGE_LC="$(printf '%s' "$IMAGE" | tr '[:upper:]' '[:lower:]')"

          ssh -i "$KEY_FILE" -p "$PORT" -o StrictHostKeyChecking=no "$USER@$HOST" \
            bash -s -- "$IMAGE_LC" "$REG_USER" "$REG_TOKEN" "$APP_PORT" <<'EOS'
          set -euo pipefail
          IMAGE="$1"
          REG_USER="$2"
          REG_TOKEN="$3"
          APP_PORT="$4"

          sudo mkdir -p /opt/chat-ws
          cd /opt/chat-ws

          sudo bash -c 'cat > .env' <<'ENVEOF'
          DOCKER_IMAGE=${{ secrets.DOCKER_IMAGE }}:latest
          SPRING_PROFILES_ACTIVE=prod
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          APP_PORT=${{ secrets.APP_PORT }}
          # WS_ENDPOINT=${{ secrets.WS_ENDPOINT }}
          ENVEOF
          sudo chmod 600 .env
          sudo chown root:root .env
  
          if [ ! -f docker-compose.yml ]; then
            sudo bash -c 'cat > docker-compose.yml' <<'YML'
services:
  chat-ws:
    image: ${DOCKER_IMAGE}
    ports:
      - "${APP_PORT:-8080}:8080"
    env_file:
      - .env
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:8080/actuator/health >/dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 15s
YML
fi
  
  docker login -u "$REG_USER" -p "$REG_TOKEN"
  docker compose pull
  docker compose up -d
  docker compose ps
  EOS
