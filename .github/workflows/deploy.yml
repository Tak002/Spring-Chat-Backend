name: build-and-deploy

on:
  push:
    branches: [ "main" ]

jobs:
  docker-build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Inject WebSocket endpoint
        run: |
          WS_ENDPOINT="${{ secrets.WS_ENDPOINT }}"
          FILE=./chat-ws/src/main/resources/static/index.html
          if [ -n "$WS_ENDPOINT" ]; then
            echo "Injecting WS_ENDPOINT=$WS_ENDPOINT into $FILE"
            sed -i "s|__WS_ENDPOINT__|$WS_ENDPOINT|g" "$FILE"
          else
            echo "[WARN] WS_ENDPOINT not set; keeping default (localhost)."
          fi
      - name: Login to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push image
        uses: docker/build-push-action@v6
        with:
          context: ./chat-ws
          file: ./chat-ws/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_IMAGE }}:latest
            ${{ secrets.DOCKER_IMAGE }}:${{ github.sha }}

  deploy:
    needs: docker-build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Prepare SSH key
        shell: bash
        run: |
          set -euo pipefail
          KEY_FILE="${RUNNER_TEMP}/ec2.key"
          printf '%s' "${{ secrets.SERVER_SSH_KEY }}" > "$KEY_FILE"
          sed -i 's/\r$//' "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          echo "KEY_FILE=$KEY_FILE" >> "$GITHUB_ENV"

      - name: Deploy over native SSH
        shell: bash
        env:
          HOST:       ${{ secrets.SERVER_HOST }}
          USER:       ${{ secrets.SERVER_USER }}
          PORT:       ${{ secrets.SERVER_SSH_PORT }}
          IMAGE:      ${{ secrets.DOCKER_IMAGE }}
          REG_USER:   ${{ secrets.REGISTRY_USERNAME }}
          REG_TOKEN:  ${{ secrets.REGISTRY_TOKEN }}
          CONTAINER:  ${{ secrets.CONTAINER_NAME }}
          APP_PORT:   ${{ secrets.APP_PORT }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        run: |
          set -euo pipefail
          : "${PORT:=22}"
          : "${CONTAINER:=websocket-app}"
          : "${APP_PORT:=8080}"

          # 이미지 레퍼런스는 소문자만 허용
          IMAGE_LC="$(printf '%s' "$IMAGE" | tr '[:upper:]' '[:lower:]')"

          # 값들을 인자로 넘겨 원격에서 안전하게 사용 (플레이스홀더 없음)
          ssh -i "$KEY_FILE" -p "$PORT" -o StrictHostKeyChecking=no "$USER@$HOST" \
            bash -s -- "$IMAGE_LC" "$REG_USER" "$REG_TOKEN" "$CONTAINER" "$APP_PORT" "$REDIS_PASSWORD" <<'EOS'
          set -euo pipefail
          IMAGE="$1"
          REG_USER="$2"
          REG_TOKEN="$3"
          CONTAINER="$4"
          APP_PORT="$5"
          REDIS_PASSWORD="$6"

          docker login -u "$REG_USER" -p "$REG_TOKEN"
          docker pull "$IMAGE:latest"

          docker stop "$CONTAINER" 2>/dev/null || true
          docker rm   "$CONTAINER" 2>/dev/null || true

          ENV_OPT=""
          if [ -f /opt/chat-ws/.env ]; then
            if [ -r /opt/chat-ws/.env ]; then
              ENV_OPT="--env-file /opt/chat-ws/.env"
            else
              echo "[WARN] /opt/chat-ws/.env exists but unreadable; running without env-file."
            fi
          else
            echo "[WARN] /opt/chat-ws/.env not found; running without env-file."
          fi
          
          docker run -d --name "$CONTAINER" \
          $ENV_OPT \
          --restart unless-stopped \
          -p "$APP_PORT":8080 \
          -e REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}' \
          "$IMAGE:latest"
              
          docker ps --filter "name=$CONTAINER"
          EOS
