#name: Auto Generate PR with Template
#
#on:
#  pull_request:
#    types: [opened, synchronize, reopened]  # PR ë³¸ë¬¸ ì—…ë°ì´íŠ¸
#    branches:
#      - main
#permissions:
#  pull-requests: write
#  issues: read
#  contents: read
#
#jobs:
#  create-or-update-pr:
#    runs-on: ubuntu-latest
#
#    steps:
#      - name: Checkout (event-aware)
#        uses: actions/checkout@v5
#        with:
#          fetch-depth: 0
#          # PR ì´ë²¤íŠ¸ë©´ head SHAë¥¼, ì•„ë‹ˆë©´ ê¸°ë³¸ê°’(ë¸Œëœì¹˜) ì‚¬ìš©
#          ref: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || '' }}
#
#      - name: Debug gh auth (PAT)
#        env:
#          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
#        run: |
#          gh --version
#          gh auth status -h github.com || true
#
#      - name: Compute Branch Name (event-aware)
#        id: branch
#        run: |
#          if [ "${{ github.event_name }}" = "pull_request" ]; then
#            echo "name=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
#          else
#            echo "name=${{ github.ref_name }}" >> $GITHUB_OUTPUT
#          fi
#
#      - name: Get Commit Messages and PR Template (event-aware)
#        id: get-content
#        run: |
#          if [ "${{ github.event_name }}" = "pull_request" ]; then
#            BASE_SHA="${{ github.event.pull_request.base.sha }}"
#            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
#            COMMITS=$(git log --pretty=format:"- %s" "${BASE_SHA}..${HEAD_SHA}" || true)
#          else
#            # push
#            git fetch origin main
#            COMMITS=$(git log origin/main..HEAD --pretty=format:"- %s" || true)
#          fi
#
#          {
#            echo "commits<<EOF"
#            echo "$COMMITS"
#            echo "EOF"
#          } >> "$GITHUB_ENV"
#
#          TEMPLATE=$(cat .github/pull_request_template.md || true)
#          {
#            echo "template<<EOF"
#            echo "$TEMPLATE"
#            echo "EOF"
#          } >> "$GITHUB_ENV"
#
#
#      - name: Generate PR Body with AI
#        id: generate-body
#        uses: actions/github-script@v8
#        with:
#          github-token: ${{ github.token }}
#          script: |
#            const commitMessages = process.env.commits;
#            const prTemplate = process.env.template;
#            const geminiApiKey = process.env.GEMINI_API_KEY;
#
#            if (!geminiApiKey) {
#              core.setFailed('GEMINI_API_KEY secret is not set.');
#              return;
#            }
#
#            const prompt = `
#              You are an expert software engineer writing a professional Pull Request description.
#              Your goal is to analyze the provided commit messages and use them to fill out the given PR template in Korean.
#              The description should be clear, technical, and help reviewers understand the purpose and details of the changes.
#
#              Follow these instructions for each section:
#
#              1.  **'## ğŸ“ ìš”ì•½ (Summary)'**: Read all commit messages and write a high-level summary of the PR's main purpose in one or two sentences.
#              2.  **'## âœ… ì£¼ìš” ë³€ê²½ ì‚¬í•­ (Key Changes)'**: Group related commits and list the most significant changes as bullet points.
#              3.  **'## ğŸ’» ìƒì„¸ êµ¬í˜„ ë‚´ìš© (Implementation Details)'**: For each key change, provide a detailed technical explanation. Focus on the "why" behind the changes. If a commit message says "refactor: ...", explain what was refactored and why the new approach is better.
#              4.  **'## ğŸš€ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… (Trouble Shooting)'**: If any commit messages start with "fix:", describe the problem that was solved. If there are no fix commits, you can state that no specific troubleshooting was required for this PR.
#              5.  **'## âš ï¸ ì•Œë ¤ì§„ ì´ìŠˆ ë° ì°¸ê³  ì‚¬í•­ (Known Issues & Notes)'**: Infer any potential follow-up work or limitations from the commits. If none are apparent, you can state that there are no known issues.
#              6.  Leave '## ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· (Screenshots)' and '## #ï¸âƒ£ ê´€ë ¨ ì´ìŠˆ (Related Issues)' sections as they are for the user to fill in.
#
#              The final output must be only the completed markdown text, perfectly matching the provided template structure. Do not add any extra text or wrappers.
#
#              --- PR í…œí”Œë¦¿ ---
#              ${prTemplate}
#
#              --- ì»¤ë°‹ ë©”ì‹œì§€ ëª©ë¡ ---
#              ${commitMessages}
#            `;
#              const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${geminiApiKey}`;
#
#              // ì¬ì‹œë„ ë¡œì§ êµ¬í˜„
#              const maxRetries = 3;
#              let lastError = null;
#
#              for (let attempt = 1; attempt <= maxRetries; attempt++) {
#              try {
#              console.log(`API í˜¸ì¶œ ì‹œë„ ${attempt}/${maxRetries}`);
#
#              const response = await fetch(apiUrl, {
#            method: 'POST',
#            headers: {
#              'Content-Type': 'application/json',
#            },
#            body: JSON.stringify({
#              contents: [{ parts: [{ text: prompt }] }],
#              generationConfig: {
#                temperature: 0.7,
#                topK: 1,
#                topP: 1,
#                maxOutputTokens: 2048,
#              },
#              safetySettings: [
#                {
#                  category: "HARM_CATEGORY_HARASSMENT",
#                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
#                },
#                {
#                  category: "HARM_CATEGORY_HATE_SPEECH",
#                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
#                },
#                {
#                  category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
#                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
#                },
#                {
#                  category: "HARM_CATEGORY_DANGEROUS_CONTENT",
#                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
#                }
#              ]
#            }),
#            });
#
#              if (!response.ok) {
#              const errorText = await response.text();
#            const error = new Error(`API request failed: ${response.status} ${response.statusText}\nError: ${errorText}`);
#
#              // 429 ì—ëŸ¬ (Rate Limit)ì¸ ê²½ìš° ì¬ì‹œë„ ëŒ€ê¸°
#              if (response.status === 429 && attempt < maxRetries) {
#              const waitTime = Math.pow(2, attempt) * 2000;
#              console.log(`Rate limit ì´ˆê³¼. ${waitTime}ms í›„ ì¬ì‹œë„...`);
#              await new Promise(resolve => setTimeout(resolve, waitTime));
#              lastError = error;
#              continue;
#            }
#
#              throw error;
#            }
#
#              const result = await response.json();
#
#              // ì „ì²´ ì‘ë‹µ ë¡œê¹… (ë””ë²„ê¹…ìš©)
#              console.log('Full Gemini Response:', JSON.stringify(result, null, 2));
#
#              // ì•ˆì „í•œ ì†ì„± ì ‘ê·¼ì„ ìœ„í•œ ê²€ì¦
#              if (!result) {
#              throw new Error('Gemini API returned null or undefined result');
#            }
#
#              // ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
#              if (result.error) {
#            throw new Error(`Gemini API returned error: ${JSON.stringify(result.error)}`);
#            }
#
#              // candidates ë°°ì—´ ê²€ì¦
#              if (!result.candidates || !Array.isArray(result.candidates) || result.candidates.length === 0) {
#            throw new Error(`Gemini API returned no candidates. This might be due to safety settings or content filtering.\nFull response: ${JSON.stringify(result)}`);
#            }
#
#              // ì²« ë²ˆì§¸ í›„ë³´ì˜ êµ¬ì¡° ê²€ì¦
#              const candidate = result.candidates[0];
#              if (!candidate || !candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
#            throw new Error(`Invalid candidate structure in Gemini response.\nCandidate: ${JSON.stringify(candidate)}`);
#            }
#
#              // ì•ˆì „í•˜ê²Œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
#              let aiResponse = candidate.content.parts[0].text;
#              if (!aiResponse || typeof aiResponse !== 'string') {
#            throw new Error(`Invalid or empty text response from Gemini.\nParts: ${JSON.stringify(candidate.content.parts)}`);
#            }
#
#              // ì‘ë‹µ ê²€ì¦ - ìµœì†Œ ê¸¸ì´ í™•ì¸
#              if (aiResponse.length < 100) {
#              throw new Error(`Generated response is too short (${aiResponse.length} characters). This might indicate an incomplete response.`);
#            }
#
#              aiResponse = aiResponse.replace(/^```markdown\n/, '').replace(/\n```$/, '');
#              console.log('Generated PR body length:', aiResponse.length);
#              console.log('Generated PR body preview:', aiResponse.substring(0, 200) + '...');
#
#              // ì¶œë ¥ ì„¤ì • ì „ì— ì ì‹œ ëŒ€ê¸°
#              await new Promise(resolve => setTimeout(resolve, 1000));
#
#              core.setOutput('body', aiResponse);
#              console.log('PR body successfully set to output');
#              return; // ì„±ê³µ ì‹œ í•¨ìˆ˜ ì¢…ë£Œ
#
#            } catch (error) {
#              lastError = error;
#              console.log(`ì‹œë„ ${attempt} ì‹¤íŒ¨:`, error.message);
#
#              if (attempt === maxRetries) {
#              break; // ë§ˆì§€ë§‰ ì‹œë„ë©´ ë£¨í”„ ì¢…ë£Œ
#            }
#
#              // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì ì‹œ ëŒ€ê¸°
#              const waitTime = 2000 * attempt; // ëŒ€ê¸° ì‹œê°„ ì¦ê°€
#              console.log(`${waitTime}ms í›„ ì¬ì‹œë„...`);
#              await new Promise(resolve => setTimeout(resolve, waitTime));
#            }
#            }
#
#              // ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°œìƒ
#            core.setFailed(`ëª¨ë“  API í˜¸ì¶œ ì‹œë„ ì‹¤íŒ¨: ${lastError?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
#              return;
#        env:
#          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
#        timeout-minutes: 10
#
#      # --------- PR ìƒì„±: push ì´ë²¤íŠ¸ì—ì„œë§Œ ---------
#      - name: Find existing PR for this branch (push only)
#        if: ${{ github.event_name == 'push' }}
#        id: find-pr
#        env:
#          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
#        run: |
#          BR="${{ steps.branch.outputs.name }}"
#          NUM=$(gh pr list \
#            --repo "${{ github.repository }}" \
#            --head "$BR" \
#            --state open \
#            --json number \
#            -q '.[0].number')
#          echo "number=$NUM" >> $GITHUB_OUTPUT
#          if [ -n "$NUM" ]; then
#            echo "Found open PR #$NUM"
#          else
#            echo "No open PR for $BR"
#          fi
#
#      - name: Create Pull Request (push only, if not exists)
#        if: ${{ github.event_name == 'push' && steps.find-pr.outputs.number == '' }}
#        env:
#          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
#          PR_BODY: ${{ steps.generate-body.outputs.body }}
#        run: |
#          gh pr create \
#            --repo "${{ github.repository }}" \
#            --base main \
#            --head "${{ steps.branch.outputs.name }}" \
#            --body "$PR_BODY" \
#            --assignee "${{ github.actor }}"
#
#      # --------- PR ë³¸ë¬¸ ì—…ë°ì´íŠ¸: PR ì´ë²¤íŠ¸ì—ì„œë§Œ ---------
#      - name: Update PR body (pull_request only)
#        if: ${{ github.event_name == 'pull_request' }}
#        env:
#          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
#          PR_BODY: ${{ steps.generate-body.outputs.body }}
#        run: |
#          gh pr edit "${{ github.event.pull_request.number }}" \
#            --repo "${{ github.repository }}" \
#            --body "$PR_BODY"
