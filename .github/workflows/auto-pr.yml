name: Auto Generate PR with Template

on:
  push:
    branches: [ "**" ]

jobs:
  create-pr:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: read
      contents: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Check if PR already exists
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          echo "Checking if PR exists for branch: ${{ github.ref_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          
          if gh pr view "${{ github.ref_name }}" --json number >/dev/null 2>&1; then
            echo "PR already exists for this branch. Skipping."
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "No PR found. Proceeding to create one."
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Get Commit Messages and PR Template
        if: steps.check_pr.outputs.exists == 'false'
        id: get-content
        run: |
          COMMITS=$(git log origin/main..HEAD --pretty=format:"- %s")
          echo "commits<<EOF" >> $GITHUB_ENV
          echo "$COMMITS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          TEMPLATE=$(cat .github/pull_request_template.md)
          echo "template<<EOF" >> $GITHUB_ENV
          echo "$TEMPLATE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Get Issue Title
        if: steps.check_pr.outputs.exists == 'false'
        id: get-issue-title
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          # 'feat#123-description' ê°™ì€ ë¸Œëœì¹˜ ì´ë¦„ì—ì„œ ìˆ«ì '123'ë§Œ ì¶”ì¶œ
          ISSUE_NUMBER=$(echo "$BRANCH_NAME" | grep -o -E '#[0-9]+' | sed 's/#//')
          
          if [ -z "$ISSUE_NUMBER" ]; then
            echo "ë¸Œëœì¹˜ ì´ë¦„ì—ì„œ ì´ìŠˆ ë²ˆí˜¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            # ì´ìŠˆ ë²ˆí˜¸ê°€ ì—†ìœ¼ë©´, ë¸Œëœì¹˜ ì´ë¦„ì„ ê¸°ë°˜ìœ¼ë¡œ ì œëª© ìƒì„±
            ISSUE_TITLE="${{ github.ref_name }}"
          else
            # GitHub CLIë¥¼ ì‚¬ìš©í•´ì„œ ì´ìŠˆ ì œëª©ì„ ê°€ì ¸ì™€
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title -q ".title")
          fi
          
          echo "title=$ISSUE_TITLE" >> $GITHUB_OUTPUT

      - name: Generate PR Body with AI
        if: steps.check_pr.outputs.exists == 'false'
        id: generate-body
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commitMessages = process.env.commits;
            const prTemplate = process.env.template;
            const geminiApiKey = process.env.GEMINI_API_KEY;

            if (!geminiApiKey) {
              core.setFailed('GEMINI_API_KEY secret is not set.');
              return;
            }

            const prompt = `
              You are an expert software engineer writing a professional Pull Request description.
              Your goal is to analyze the provided commit messages and use them to fill out the given PR template in Korean.
              The description should be clear, technical, and help reviewers understand the purpose and details of the changes.

              Follow these instructions for each section:

              1.  **'## ğŸ“ ìš”ì•½ (Summary)'**: Read all commit messages and write a high-level summary of the PR's main purpose in one or two sentences.
              2.  **'## âœ… ì£¼ìš” ë³€ê²½ ì‚¬í•­ (Key Changes)'**: Group related commits and list the most significant changes as bullet points.
              3.  **'## ğŸ’» ìƒì„¸ êµ¬í˜„ ë‚´ìš© (Implementation Details)'**: For each key change, provide a detailed technical explanation. Focus on the "why" behind the changes. If a commit message says "refactor: ...", explain what was refactored and why the new approach is better.
              4.  **'## ğŸš€ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… (Trouble Shooting)'**: If any commit messages start with "fix:", describe the problem that was solved. If there are no fix commits, you can state that no specific troubleshooting was required for this PR.
              5.  **'## âš ï¸ ì•Œë ¤ì§„ ì´ìŠˆ ë° ì°¸ê³  ì‚¬í•­ (Known Issues & Notes)'**: Infer any potential follow-up work or limitations from the commits. If none are apparent, you can state that there are no known issues.
              6.  Leave '## ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· (Screenshots)' and '## #ï¸âƒ£ ê´€ë ¨ ì´ìŠˆ (Related Issues)' sections as they are for the user to fill in.

              The final output must be only the completed markdown text, perfectly matching the provided template structure. Do not add any extra text or wrappers.

              --- PR í…œí”Œë¦¿ ---
              ${prTemplate}

              --- ì»¤ë°‹ ë©”ì‹œì§€ ëª©ë¡ ---
              ${commitMessages}
            `;

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${geminiApiKey}`;
            
            // ì¬ì‹œë„ ë¡œì§ êµ¬í˜„
            const maxRetries = 3;
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
              try {
                console.log(`API í˜¸ì¶œ ì‹œë„ ${attempt}/${maxRetries}`);
            
                const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                      temperature: 0.7,
                      topK: 1,
                      topP: 1,
                      maxOutputTokens: 2048,
                    },
                    safetySettings: [
                      {
                        category: "HARM_CATEGORY_HARASSMENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_HATE_SPEECH",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      }
                    ]
                  }),
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  const error = new Error(`API request failed: ${response.status} ${response.statusText}\nError: ${errorText}`);
            
                  // 429 ì—ëŸ¬ (Rate Limit)ì¸ ê²½ìš° ì¬ì‹œë„ ëŒ€ê¸°
                  if (response.status === 429 && attempt < maxRetries) {
                    const waitTime = Math.pow(2, attempt) * 2000;
                    console.log(`Rate limit ì´ˆê³¼. ${waitTime}ms í›„ ì¬ì‹œë„...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    lastError = error;
                    continue;
                  }
            
                  throw error;
                }

                const result = await response.json();
            
                // ì „ì²´ ì‘ë‹µ ë¡œê¹… (ë””ë²„ê¹…ìš©)
                console.log('Full Gemini Response:', JSON.stringify(result, null, 2));

                // ì•ˆì „í•œ ì†ì„± ì ‘ê·¼ì„ ìœ„í•œ ê²€ì¦
                if (!result) {
                  throw new Error('Gemini API returned null or undefined result');
                }

                // ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
                if (result.error) {
                  throw new Error(`Gemini API returned error: ${JSON.stringify(result.error)}`);
                }

                // candidates ë°°ì—´ ê²€ì¦
                if (!result.candidates || !Array.isArray(result.candidates) || result.candidates.length === 0) {
                  throw new Error(`Gemini API returned no candidates. This might be due to safety settings or content filtering.\nFull response: ${JSON.stringify(result)}`);
                }

                // ì²« ë²ˆì§¸ í›„ë³´ì˜ êµ¬ì¡° ê²€ì¦
                const candidate = result.candidates[0];
                if (!candidate || !candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                  throw new Error(`Invalid candidate structure in Gemini response.\nCandidate: ${JSON.stringify(candidate)}`);
                }

                // ì•ˆì „í•˜ê²Œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                let aiResponse = candidate.content.parts[0].text;
                if (!aiResponse || typeof aiResponse !== 'string') {
                  throw new Error(`Invalid or empty text response from Gemini.\nParts: ${JSON.stringify(candidate.content.parts)}`);
                }

                // ì‘ë‹µ ê²€ì¦ - ìµœì†Œ ê¸¸ì´ í™•ì¸
                if (aiResponse.length < 100) {
                  throw new Error(`Generated response is too short (${aiResponse.length} characters). This might indicate an incomplete response.`);
                }

                aiResponse = aiResponse.replace(/^```markdown\n/, '').replace(/\n```$/, '');
                console.log('Generated PR body length:', aiResponse.length);
                console.log('Generated PR body preview:', aiResponse.substring(0, 200) + '...');
            
                // ì¶œë ¥ ì„¤ì • ì „ì— ì ì‹œ ëŒ€ê¸°
                await new Promise(resolve => setTimeout(resolve, 1000));
            
                core.setOutput('body', aiResponse);
                console.log('PR body successfully set to output');
                return; // ì„±ê³µ ì‹œ í•¨ìˆ˜ ì¢…ë£Œ

              } catch (error) {
                lastError = error;
                console.log(`ì‹œë„ ${attempt} ì‹¤íŒ¨:`, error.message);
            
                if (attempt === maxRetries) {
                  break; // ë§ˆì§€ë§‰ ì‹œë„ë©´ ë£¨í”„ ì¢…ë£Œ
                }
            
                // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì ì‹œ ëŒ€ê¸°
                const waitTime = 2000 * attempt; // ëŒ€ê¸° ì‹œê°„ ì¦ê°€
                console.log(`${waitTime}ms í›„ ì¬ì‹œë„...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
              }
            }
            
            // ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°œìƒ
            core.setFailed(`ëª¨ë“  API í˜¸ì¶œ ì‹œë„ ì‹¤íŒ¨: ${lastError?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
            return;
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        timeout-minutes: 10 # íƒ€ì„ì•„ì›ƒ ì‹œê°„ ì¦ê°€

      - name: Create Pull Request
        if: steps.check_pr.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          PR_BODY: ${{ steps.generate-body.outputs.body }}
        run: |
          # PR bodyê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
          if [ -z "$PR_BODY" ]; then
            echo "Error: PR body is empty. Skipping PR creation."
            exit 1
          fi
          
          echo "PR body length: ${#PR_BODY}"
          echo "PR body preview: ${PR_BODY:0:200}..."
          
          # ì¬ì‹œë„ ë¡œì§ìœ¼ë¡œ PR ìƒì„±
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "PR ìƒì„± ì‹œë„ $attempt/$max_attempts"
          
            # ì ì‹œ ëŒ€ê¸° (ì ì§„ì ìœ¼ë¡œ ì¦ê°€)
            wait_time=$((attempt * 5))
            echo "ëŒ€ê¸° ì‹œê°„: ${wait_time}ì´ˆ"
            sleep $wait_time
          
            # GitHub API ìƒíƒœ í™•ì¸
            echo "GitHub API ìƒíƒœ í™•ì¸ ì¤‘..."
            if ! gh api rate-limit > /dev/null 2>&1; then
              echo "GitHub API ì—°ê²° ë¬¸ì œ. ì¬ì‹œë„ ì¤‘..."
              continue
            fi
          
            # PR ìƒì„± ì‹œë„
            if gh pr create \
              --base main \
              --head ${{ github.ref_name }} \
              --title "${{ github.ref_name }}" \
              --body "$PR_BODY" \
              --assignee ${{ github.actor }}; then
          
              echo "Pull Request created successfully!"
              break
            else
              echo "PR ìƒì„± ì‹¤íŒ¨ (ì‹œë„ $attempt/$max_attempts)"
          
              if [ $attempt -eq $max_attempts ]; then
                echo "ëª¨ë“  PR ìƒì„± ì‹œë„ ì‹¤íŒ¨. ìˆ˜ë™ìœ¼ë¡œ PRì„ ìƒì„±í•´ì£¼ì„¸ìš”."
                echo "ë¸Œëœì¹˜: ${{ github.ref_name }}"
                echo "PR ë‚´ìš© ê¸¸ì´: ${#PR_BODY}"
                exit 1
              fi
            fi
          done