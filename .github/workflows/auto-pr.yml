name: Auto Generate PR with Template

on:
  push:
    branches: [ "**" ]

permissions:            # ✅ 워크플로 상단에 명시 (org 기본 정책 무시용)
  pull-requests: write
  issues: read
  contents: read

jobs:
  create-pr:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}   # ✅ gh는 이 토큰만 사용
      GH_HOST: github.com             # ✅ 호스트 명시 (혹시 모를 엔터프라이즈/커스텀 도메인 이슈 방지)

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # 기본 GITHUB_TOKEN이면 충분. 별도 token 불필요

      - name: Debug gh auth
        run: |
          set -xe
          gh --version
          # 현재 인증 상태/호스트 확인
          gh auth status -h "$GH_HOST" || true
          # API 호출이 실제로 가능한지 바로 확인
          gh api rate-limit -H 'Accept: application/vnd.github+json' || true
          # 어떤 리포를 바라보고 있는지 명시 (정보 출력용)
          echo "Repo: $GITHUB_REPOSITORY  Ref: $GITHUB_REF  RefName: $GITHUB_REF_NAME"

      - name: Get Commit Messages and PR Template
        id: get-content
        run: |
          set -e
          COMMITS=$(git log origin/main..HEAD --pretty=format:"- %s" || true)
          {
            echo "commits<<EOF"
            echo "$COMMITS"
            echo "EOF"
          } >> "$GITHUB_ENV"

          TEMPLATE=$(cat .github/pull_request_template.md || true)
          {
            echo "template<<EOF"
            echo "$TEMPLATE"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Get Issue Title
        id: get-issue-title
        run: |
          set -e
          BRANCH_NAME="${{ github.ref_name }}"
          ISSUE_NUMBER=$(echo "$BRANCH_NAME" | grep -o -E '#[0-9]+' | sed 's/#//')
          if [ -z "$ISSUE_NUMBER" ]; then
            ISSUE_TITLE="${{ github.ref_name }}"
          else
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title -q ".title")
          fi
          echo "title=$ISSUE_TITLE" >> $GITHUB_OUTPUT

      - name: Generate PR Body with AI
        id: generate-body
        uses: actions/github-script@v6
        with:
          github-token: ${{ github.token }}
          script: |
            const commitMessages = process.env.commits;
            const prTemplate = process.env.template;
            const geminiApiKey = process.env.GEMINI_API_KEY;

            if (!geminiApiKey) {
              core.setFailed('GEMINI_API_KEY secret is not set.');
              return;
            }

            const prompt = `
              You are an expert software engineer writing a professional Pull Request description.
              Your goal is to analyze the provided commit messages and use them to fill out the given PR template in Korean.
              The description should be clear, technical, and help reviewers understand the purpose and details of the changes.

              Follow these instructions for each section:

              1.  **'## 📝 요약 (Summary)'**: Read all commit messages and write a high-level summary of the PR's main purpose in one or two sentences.
              2.  **'## ✅ 주요 변경 사항 (Key Changes)'**: Group related commits and list the most significant changes as bullet points.
              3.  **'## 💻 상세 구현 내용 (Implementation Details)'**: For each key change, provide a detailed technical explanation. Focus on the "why" behind the changes. If a commit message says "refactor: ...", explain what was refactored and why the new approach is better.
              4.  **'## 🚀 트러블 슈팅 (Trouble Shooting)'**: If any commit messages start with "fix:", describe the problem that was solved. If there are no fix commits, you can state that no specific troubleshooting was required for this PR.
              5.  **'## ⚠️ 알려진 이슈 및 참고 사항 (Known Issues & Notes)'**: Infer any potential follow-up work or limitations from the commits. If none are apparent, you can state that there are no known issues.
              6.  Leave '## 📸 스크린샷 (Screenshots)' and '## #️⃣ 관련 이슈 (Related Issues)' sections as they are for the user to fill in.

              The final output must be only the completed markdown text, perfectly matching the provided template structure. Do not add any extra text or wrappers.

              --- PR 템플릿 ---
              ${prTemplate}

              --- 커밋 메시지 목록 ---
              ${commitMessages}
            `;

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${geminiApiKey}`;
            
            // 재시도 로직 구현
            const maxRetries = 3;
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
              try {
                console.log(`API 호출 시도 ${attempt}/${maxRetries}`);
            
                const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                      temperature: 0.7,
                      topK: 1,
                      topP: 1,
                      maxOutputTokens: 2048,
                    },
                    safetySettings: [
                      {
                        category: "HARM_CATEGORY_HARASSMENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_HATE_SPEECH",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      }
                    ]
                  }),
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  const error = new Error(`API request failed: ${response.status} ${response.statusText}\nError: ${errorText}`);
            
                  // 429 에러 (Rate Limit)인 경우 재시도 대기
                  if (response.status === 429 && attempt < maxRetries) {
                    const waitTime = Math.pow(2, attempt) * 2000;
                    console.log(`Rate limit 초과. ${waitTime}ms 후 재시도...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    lastError = error;
                    continue;
                  }
            
                  throw error;
                }

                const result = await response.json();
            
                // 전체 응답 로깅 (디버깅용)
                console.log('Full Gemini Response:', JSON.stringify(result, null, 2));

                // 안전한 속성 접근을 위한 검증
                if (!result) {
                  throw new Error('Gemini API returned null or undefined result');
                }

                // 에러 응답 처리
                if (result.error) {
                  throw new Error(`Gemini API returned error: ${JSON.stringify(result.error)}`);
                }

                // candidates 배열 검증
                if (!result.candidates || !Array.isArray(result.candidates) || result.candidates.length === 0) {
                  throw new Error(`Gemini API returned no candidates. This might be due to safety settings or content filtering.\nFull response: ${JSON.stringify(result)}`);
                }

                // 첫 번째 후보의 구조 검증
                const candidate = result.candidates[0];
                if (!candidate || !candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                  throw new Error(`Invalid candidate structure in Gemini response.\nCandidate: ${JSON.stringify(candidate)}`);
                }

                // 안전하게 텍스트 추출
                let aiResponse = candidate.content.parts[0].text;
                if (!aiResponse || typeof aiResponse !== 'string') {
                  throw new Error(`Invalid or empty text response from Gemini.\nParts: ${JSON.stringify(candidate.content.parts)}`);
                }

                // 응답 검증 - 최소 길이 확인
                if (aiResponse.length < 100) {
                  throw new Error(`Generated response is too short (${aiResponse.length} characters). This might indicate an incomplete response.`);
                }

                aiResponse = aiResponse.replace(/^```markdown\n/, '').replace(/\n```$/, '');
                console.log('Generated PR body length:', aiResponse.length);
                console.log('Generated PR body preview:', aiResponse.substring(0, 200) + '...');
            
                // 출력 설정 전에 잠시 대기
                await new Promise(resolve => setTimeout(resolve, 1000));
            
                core.setOutput('body', aiResponse);
                console.log('PR body successfully set to output');
                return; // 성공 시 함수 종료

              } catch (error) {
                lastError = error;
                console.log(`시도 ${attempt} 실패:`, error.message);
            
                if (attempt === maxRetries) {
                  break; // 마지막 시도면 루프 종료
                }
            
                // 마지막 시도가 아니면 잠시 대기
                const waitTime = 2000 * attempt; // 대기 시간 증가
                console.log(`${waitTime}ms 후 재시도...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
              }
            }
            
            // 모든 재시도 실패 시 에러 발생
            core.setFailed(`모든 API 호출 시도 실패: ${lastError?.message || '알 수 없는 오류'}`);
            return;
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        timeout-minutes: 10

      - name: Create Pull Request (gh cli)
        if: ${{ github.ref_name != 'main' }}
        env:
          PR_BODY: ${{ steps.generate-body.outputs.body }}
        run: |
          set -e
          if [ -z "$PR_BODY" ]; then
            echo "Error: PR body is empty. Skipping PR creation."
            exit 1
          fi

          echo "PR body length: ${#PR_BODY}"
          echo "PR body preview: ${PR_BODY:0:200}..."

          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "PR 생성 시도 $attempt/$max_attempts"
            wait_time=$((attempt * 5))
            echo "대기 시간: ${wait_time}초"
            sleep $wait_time

            # gh가 실패하면 에러 로그를 그대로 출력해서 원인 파악
            if gh pr create \
              --repo "${{ github.repository }}" \
              --base main \
              --head "${{ github.ref_name }}" \
              --title "${{ steps.get-issue-title.outputs.title }}" \
              --body "$PR_BODY" \
              --assignee "${{ github.actor }}"; then
              echo "Pull Request created successfully!"
              exit 0
            else
              echo "gh pr create 실패 (시도 $attempt/$max_attempts). 직전 명령의 종료코드: $?"
              # 추가로 상태 확인
              gh auth status -h "$GH_HOST" || true
              gh api rate-limit -H 'Accept: application/vnd.github+json' || true
              if [ $attempt -eq $max_attempts ]; then
                echo "gh 경로 실패, REST API 대체 경로 시도..."
              fi
            fi
          done
          # 여기까지 오면 gh 실패 -> REST 대체
          echo "===> REST API로 PR 생성 시도"
          TITLE_JSON=$(printf '%s' "${{ steps.get-issue-title.outputs.title }}" | jq -Rsa .)
          BODY_JSON=$(printf '%s' "$PR_BODY" | jq -Rsa .)
          DATA=$(jq -cn --arg title "$(jq -r . <<<"$TITLE_JSON")" \
                        --arg head  "${{ github.ref_name }}" \
                        --arg base  "main" \
                        --arg body  "$(jq -r . <<<"$BODY_JSON")" \
                        '{title:$title, head:$head, base:$base, body:$body}')
          curl -sS -X POST \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d "$DATA" | tee /tmp/pr_create.json

          # 성공/실패 검사
          html_url=$(jq -r '.html_url // empty' /tmp/pr_create.json)
          if [ -n "$html_url" ]; then
            echo "REST API로 PR 생성 성공: $html_url"
          else
            echo "REST API로도 PR 생성 실패"
            echo "응답:"
            cat /tmp/pr_create.json
            exit 1
          fi
