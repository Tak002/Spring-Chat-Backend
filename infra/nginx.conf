# 워커 프로세스 레벨 설정 (여기서는 기본값 사용)
events {}

http {
    ########################################################################
    # [공통 프록시 동작 기본값 설정 영역]
    #
    # 이 블록 안에서 지정한 proxy_* 헤더들은 아래의 모든 server/location에
    # 기본적으로 적용된다. 즉 각 location마다 반복해서 넣지 않아도 된다.
    #
    # 목적:
    #  - 백엔드(Spring)에서 원래 Host/Client IP/Protocol 정보를 알 수 있게 전달
    #  - 로깅 및 보안 감사(IP 추적 등)에 유용
    ########################################################################

    # 클라이언트가 원래 어떤 Host(도메인)로 요청했는지 그대로 전달
    proxy_set_header Host              $host;

    # 실제 클라이언트 IP (NGINX가 프록시니까, 이걸 안 보내면 백엔드에서는 NGINX IP만 보임)
    proxy_set_header X-Real-IP         $remote_addr;

    # 프록시 체인을 따라온 모든 IP를 기록 (로드밸런서, 프록시 등 여러 홉이 있는 경우 추적 가능)
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;

    # 클라이언트가 HTTP로 왔는지 HTTPS로 왔는지 등을 백엔드에 알려줌
    # (리다이렉트 URL 계산, 보안 정책 등에 쓰일 수 있음)
    proxy_set_header X-Forwarded-Proto $scheme;

    # 어떤 Host로 접근했는지 (리다이렉트/링크 생성 등에 쓰일 수 있음)
    proxy_set_header X-Forwarded-Host  $host;

    # 기본 응답 타임아웃 (일반 REST API 등에 적용)
    # WebSocket은 아래에서 별도로 늘린다.
    proxy_read_timeout 300s;


    ########################################################################
    # [로그 설정]
    #
    # proxy_debug 포맷:
    #  - 어떤 클라이언트가
    #  - 어떤 호스트/메서드/URI로 요청했고
    #  - 어느 업스트림으로 라우팅됐는지
    #  - 응답 지연은 어땠는지
    # 를 한 줄로 찍는다.
    #
    # 로그 출력 위치:
    #  - access_log: /dev/stdout  (컨테이너 stdout으로 가게 해서 도커 logs 등으로 바로 확인)
    #  - error_log : /dev/stderr  (에러/경고는 stderr로 분리)
    ########################################################################
    log_format proxy_debug
        'client:$remote_addr '
        'vhost:$host '
        'method:$request_method '
        'req:"$request_uri" '
        'norm_uri:"$uri" '
        'upstream_name:$upstream_name '
        'upstream_addr:$upstream_addr '
        'status:$status(up:$upstream_status) '
        'rt:$request_time urt:$upstream_response_time';

    access_log /dev/stdout proxy_debug;
    error_log  /dev/stderr warn;


    ########################################################################
    # [WebSocket 업그레이드 처리용 map]
    #
    # HTTP/1.1에서 WebSocket으로 업그레이드할 때
    #  - Upgrade: websocket
    #  - Connection: upgrade
    # 헤더 조합이 필요하다.
    #
    # SockJS는 WebSocket 외에도 XHR 폴백을 쓰는데,
    # 업그레이드 헤더가 비어 있는 경우에는 keep-alive/close 등 일반 커넥션으로 취급해야 한다.
    #
    # 아래 map은 $http_upgrade 값(클라이언트가 보낸 Upgrade 헤더 유무)에 따라
    # 우리가 보낼 Connection 헤더 값을 동적으로 결정하기 위한 것이다.
    ########################################################################
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }


    ########################################################################
    # [업스트림 블록]
    #
    # docker-compose 서비스 이름(:포트)으로 백엔드 컨테이너들을 가리킨다.
    # 필요하면 scale-out 시 server 라인을 여러 개 추가해서 로드밸런싱 가능.
    #
    # 예) chat_ws는 WebSocket/STOMP 엔드포인트 (/ws-sockjs 등)를 처리하는 Spring Boot
    ########################################################################
    upstream chat_ws        { server chat-ws:8080; }
    upstream chat_history   { server chat-history:8080; }
    upstream app_service    { server app-service:8080; }
    upstream app_media      { server app-media:8080; }
    upstream app_auth       { server app-auth:8080; }


    ########################################################################
    # [가상 서버 블록]
    #
    # listen 80: NGINX가 외부에서 80 포트(HTTP)로 들어오는 요청을 받고,
    # path prefix에 따라 위에서 정의한 upstream들로 라우팅해준다.
    #
    # $upstream_name 변수:
    #  - access_log에서 "이 요청은 어느 백엔드로 갔다"를 보기 좋게 하기 위한 커스텀 변수
    #  - server 시작 시 기본값 "-" 로 세팅해두고,
    #    각 location 안에서 적절한 이름으로 덮어쓴다.
    ########################################################################
    server {
        listen 80;
        set $upstream_name "-";

        ####################################################################
        # [헬스체크/동작 확인용 루트 엔드포인트]
        #
        # GET / 로 접근하면 단순 텍스트로 현재 프록시가 떠있음을 알려준다.
        # 이건 k8s livenessProbe/readinessProbe, 수동 curl 테스트 등에 유용하다.
        ####################################################################
        location = / {
            add_header Content-Type text/plain;
            return 200 "NGINX reverse proxy is up. Try /ws-sockjs, /history, /api, /media, /auth\n";
        }

        ####################################################################
        # [/ws-sockjs → chat_ws]
        #
        # SockJS/STOMP 엔드포인트. 예:
        #   /ws-sockjs/info?t=...
        #   /ws-sockjs/{server-id}/{session-id}/websocket
        #   /ws-sockjs/{server-id}/{session-id}/xhr
        #
        # 특징:
        #  - WebSocket 업그레이드 지원 (Upgrade/Connection 헤더 설정)
        #  - 긴 연결(WebSocket or long-polling) 유지 위해 timeout 크게 설정
        #
        # proxy_pass http://chat_ws;
        #   → 외부 /ws-sockjs/... 경로를 내부 chat_ws 서비스의 동일 경로로 그대로 전달
        ####################################################################
        location /ws-sockjs {
            set $upstream_name "chat_ws";

            # 실제 백엔드(Spring WebSocket/STOMP 서버)로 라우팅
            proxy_pass http://chat_ws;

            # WebSocket은 반드시 HTTP/1.1로 업그레이드
            proxy_http_version 1.1;

            # --- WebSocket 업그레이드 관련 헤더 ---
            proxy_set_header Upgrade    $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # --- 여기부터가 핵심: 전역 헤더를 다시 명시적으로 선언해줘야 한다 ---
            # (이 블록 안에서 proxy_set_header를 쓴 순간 상속이 끊기기 때문)
            proxy_set_header Host              $host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host  $host;

            # WebSocket / long-poll 연결은 오래 유지되니까 timeout을 넉넉하게
            proxy_read_timeout  3600;
            proxy_send_timeout  3600;
        }
        ####################################################################
        # [/chat/ → chat_ws]
        #
        # chat_ws 서비스로 라우팅되는 HTTP API/기능 (예: 채팅 관련 REST 등).
        #
        # 여기서 proxy_pass 뒤에 슬래시(/)를 붙이지 않았다.
        #   proxy_pass http://chat_ws;
        # 라는 형태는
        #   요청 경로(/chat/xxx)를 그대로 백엔드에 전달(/chat/xxx 유지)
        # 라는 의미다.
        #
        # 즉 chat_ws 내부 컨트롤러도 /chat/** 같은 prefix를 예상하고 있어야 한다.
        ####################################################################
        location /chat/ {
            set $upstream_name "chat_ws";
            proxy_pass http://chat_ws;
        }

        ####################################################################
        # [/history/ → chat_history]
        #
        # 과거 메시지 조회, 기록(영구 저장) 조회 등 히스토리성 API를
        # 별도의 서비스(chat_history)로 보낸다.
        #
        # 동일하게 prefix(/history/...)를 유지한 채로 넘긴다.
        ####################################################################
        location /history/ {
            set $upstream_name "chat_history";
            proxy_pass http://chat_history;
        }

        ####################################################################
        # [/api/ → app_service]
        #
        # 메인 앱 서비스(도메인 로직, 일반 비즈니스 API 등)를 app_service로 분리.
        # 역시 /api/... prefix를 그대로 유지해서 전달한다.
        ####################################################################
        location /api/ {
            set $upstream_name "app_service";
            proxy_pass http://app_service;
        }

        ####################################################################
        # [/media/ → app_media]
        #
        # 파일 업로드/다운로드, 미디어 처리 전용 서비스로 트래픽을 분리.
        # 대용량 I/O나 정적/반정적 리소스 처리가 여기에 몰려도
        # 다른 서비스에 영향을 덜 주게 하는 구조.
        ####################################################################
        location /media/ {
            set $upstream_name "app_media";
            proxy_pass http://app_media;
        }

        ####################################################################
        # [/auth/ → app_auth]
        #
        # 인증/인가 관련 API를 app_auth로 별도 라우팅한다.
        # refresh token 발급/검증, 로그인 등의 보안 민감 로직을
        # 전용 서비스로 분리하여 경계를 명확히 하려는 의도.
        #
        # 마찬가지로 /auth/... prefix를 유지한 채로 전달한다.
        ####################################################################
        location /auth/ {
            set $upstream_name "app_auth";
            proxy_pass http://app_auth;
        }
    }
}
